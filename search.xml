<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Verilog</title>
    <url>/2022/12/12/Verilog/</url>
    <content><![CDATA[<p>本文记录寒假器件自学verilog的笔记。</p>
<span id="more"></span>
<h1 id="第二章-Verilog语法的基本概念"><a href="#第二章-Verilog语法的基本概念" class="headerlink" title="第二章 Verilog语法的基本概念"></a>第二章 Verilog语法的基本概念</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>VerilogHDL描述的电路设计为该电路的Verilog HDL模型，也称为模块。VerilogHDL即使一种行为描述语言也是一种结构描述语言。可以将功能行为模块通过工具自动的转换为门级互联的结构模块。<br>它可以是实际电路不同级别的抽象</p>
<ul>
<li>系统级</li>
<li>算法级 algorithm level</li>
<li>RTL级 register transfer level<br>（以上三种属于行为级，只有RTL级彩玉逻辑电路有明确的对应关系）</li>
<li>门级</li>
<li>开关级</li>
</ul>
<h2 id="2-2-Verilog模块的基本概念"><a href="#2-2-Verilog模块的基本概念" class="headerlink" title="2.2 Verilog模块的基本概念"></a>2.2 Verilog模块的基本概念</h2><p>先用例子了解Verilog模块的特性：</p>
<ul>
<li><p>多路选择器<img src="https://raw.githubusercontent.com/TianZhongxu/BlogImage/main/img/20221227160423.png"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> muxtwo(out,a,b,sl);</span><br><span class="line"><span class="keyword">input</span> a,b,sl;<span class="comment">//输入信号名</span></span><br><span class="line"><span class="keyword">output</span> out;<span class="comment">//输出信号名</span></span><br><span class="line"><span class="keyword">reg</span> out;</span><br><span class="line"><span class="keyword">always</span> @ (sl <span class="keyword">or</span> a <span class="keyword">or</span> b)</span><br><span class="line">	<span class="keyword">if</span>(!sl)</span><br><span class="line">		out=a;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		out=b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>带有与非门的二选一多路选择器<img src="https://raw.githubusercontent.com/TianZhongxu/BlogImage/main/img/20221227160502.png"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> muxtwo(out,a,b,sl);</span><br><span class="line"><span class="keyword">input</span> a,b,sl;<span class="comment">//输入信号名</span></span><br><span class="line"><span class="keyword">output</span> out; <span class="comment">//输出信号名 </span></span><br><span class="line"><span class="keyword">wire</span> nsl, sela, selb;<span class="comment">//定义内部连接线 </span></span><br><span class="line"><span class="keyword">assign</span> nsl= ~sl;<span class="comment">//求反 </span></span><br><span class="line"><span class="keyword">assign</span> sela= a &amp; nsl;<span class="comment">// 按位与运算 </span></span><br><span class="line"><span class="keyword">assign</span> selb= b &amp; sl; </span><br><span class="line"><span class="keyword">assign</span> out= sela | selb;<span class="comment">//按位或运算 </span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> muxtwo (out, a, b, sl); </span><br><span class="line"><span class="keyword">input</span> a, b, sl; </span><br><span class="line"><span class="keyword">output</span> out; <span class="keyword">not</span> u1(nsl, sl); </span><br><span class="line"><span class="keyword">and</span> #<span class="number">1</span> u2(sela, a, nsl); </span><br><span class="line"><span class="keyword">and</span> #<span class="number">1</span> u3(selb, b, sl); </span><br><span class="line"><span class="keyword">or</span> #<span class="number">1</span> u4(out, sela, selb); </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面这些例子都是可以综合的，所谓综合就是将HDL转化为电路并有源。</p>
<h2 id="2-3-Verilog用于模块的测试"><a href="#2-3-Verilog用于模块的测试" class="headerlink" title="2.3 Verilog用于模块的测试"></a>2.3 Verilog用于模块的测试</h2><p>Verilog还可以用来描述变化的测试信号，称为测试平台（testbench）。通过观测被测试模块的输出信号是否符合要求，可以调试和验证逻辑系统的设计和结构正确与否。<br>例如，将上例中的多路器模块进行测试</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&#x27;<span class="keyword">include</span> <span class="string">&quot;muxtwo.v&quot;</span> <span class="keyword">module</span> t；</span><br><span class="line"><span class="keyword">reg</span> ain，bin，select； </span><br><span class="line"><span class="keyword">reg</span> clock； </span><br><span class="line"><span class="keyword">wire</span> outw； </span><br><span class="line"><span class="keyword">initial</span> <span class="comment">//把寄存器变量初始化为一的确定值 </span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">	ain = <span class="number">0</span>; </span><br><span class="line">	bin = <span class="number">0</span>; </span><br><span class="line">	select = <span class="number">0</span>; </span><br><span class="line">	clock = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">always</span> #<span class="number">50</span> clock=~clock； <span class="comment">//产生一个不断重复的周期为100个的时钟信号clock</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) </span><br><span class="line"><span class="keyword">begin</span> <span class="comment">// &#123;$random&#125;为系统任务，会产生一个随机数 </span></span><br><span class="line">#<span class="number">1</span> ain= &#123;<span class="built_in">$random</span>) % <span class="number">2</span>; <span class="comment">//产生随机的位信号流ain和bin，％2为模2运算 </span></span><br><span class="line">#<span class="number">3</span> bin= &#123;<span class="built_in">$random</span>&#125; % <span class="number">2</span>;<span class="comment">//分别延迟1和3个时间单位后产生随机的位信号流ain和bin</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">always</span> #<span class="number">10000</span> select = !select; <span class="comment">//产生周期为10000个单位时间的选通信号变化 //... </span></span><br><span class="line">muxtwo m(<span class="variable">.out</span>(outw)，<span class="variable">.a</span>(ain), <span class="variable">.b</span>(bin), <span class="variable">.sl</span>(select)); </span><br><span class="line"><span class="comment">/* 实例引用多路器，并加入测试信号流，以观察模块的输出out。其中，muxtwo是已经定义的 （行为的或结构的）模块，m表示在本测试模块中有一个名为m的muxtwo的模块，其四个端口分别 为：.out( )，.a( )，.b( )，.sl( )， . 表示端口；后面紧跟端口名，其名称必须与 muxtwo模块定义的端口名一致；小括号内的信号名为与该端口连接的信号线名，可以用别的名，但 必须在本模块中定义，说明其类型。 */</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>RS出发器的测试<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先需要有rs_flipflop的Verilog描述</span></span><br><span class="line">timescale <span class="number">10</span>ns/<span class="number">1</span>ns</span><br><span class="line"><span class="keyword">module</span> rs_filpflop(q,qbar,r,s);</span><br><span class="line"><span class="keyword">output</span> q,qbar;</span><br><span class="line"><span class="keyword">input</span> r,s;</span><br><span class="line"><span class="keyword">nand</span> #<span class="number">1</span> (q,r,qbar);</span><br><span class="line"><span class="keyword">nand</span> #<span class="number">1</span> (qbar,s,q);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//然后验证</span></span><br><span class="line"><span class="keyword">module</span> text_rs_flipflop；</span><br><span class="line"><span class="keyword">reg</span> ts,tr;</span><br><span class="line"><span class="keyword">wire</span> tq,tqb;</span><br><span class="line">rs_flipflop u_rsff(<span class="variable">.q</span>(tq),<span class="variable">.s</span>(ts),<span class="variable">.r</span>(tr),<span class="variable">.qbar</span>(tqb));<span class="comment">//被测模块实例引用</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span><span class="comment">//第一个initial语句给出激励</span></span><br><span class="line">	tr=<span class="number">0</span>;</span><br><span class="line">	ts=<span class="number">0</span>;</span><br><span class="line">	#<span class="number">5</span> ts=<span class="number">1</span></span><br><span class="line">	#<span class="number">5</span> ts=<span class="number">0</span>;</span><br><span class="line">	tr=<span class="number">1</span></span><br><span class="line">	#<span class="number">5</span> ts=<span class="number">1</span>;</span><br><span class="line">	tr=<span class="number">0</span>;</span><br><span class="line">	#<span class="number">5</span> ts=<span class="number">0</span>；</span><br><span class="line">	#<span class="number">5</span> tr=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">	<span class="built_in">$monitor</span>(<span class="string">&quot;at time %t,&quot;</span>,<span class="built_in">$time</span>,<span class="string">&quot;tr=%b,tq=%b,tqb=%b&quot;</span>,tr,ts,tq,tqb);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
输出的波形如下：<br><img src="https://raw.githubusercontent.com/TianZhongxu/BlogImage/main/img/20221227162729.png"></li>
</ul>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>通过众多例子可以看到：</p>
<ul>
<li>所有模块的内容都位于module和endmodule两个语句中间</li>
<li>模块是可以进行层次嵌套的</li>
<li>如果每个模块都是可以综合的，则通过综合工具可以把 它们的功能描述全都转换为最基本的逻辑单元描述，最 后可以用一个上层模块通过实例引用把这些模块连接起 来，把它们整合成一个很大的逻辑系统。</li>
<li>Verilog模块可以分为两种类型：一种是为了让模块最终能生成电路结构，另一种是为了测试所设计电路的逻辑功能是否正确。</li>
</ul>
]]></content>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
</search>
